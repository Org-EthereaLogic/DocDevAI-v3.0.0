"""
Vulnerability Scanner Component
Scans dependencies for known security vulnerabilities
"""

import json
import hashlib
from typing import List, Dict, Any, Optional
from pathlib import Path
from datetime import datetime


class VulnerabilityScanner:
    """
    Scans components for known security vulnerabilities
    Uses local vulnerability database (no external API calls for privacy)
    """
    
    def __init__(self):
        """Initialize vulnerability scanner with local database"""
        # In production, this would load from a local vulnerability database
        # For now, we'll use a simplified example database
        self.vulnerability_db = self._load_vulnerability_database()
        
    def scan(self, components: List) -> List:
        """
        Scan components for vulnerabilities
        
        Args:
            components: List of Component objects to scan
            
        Returns:
            List of Vulnerability objects
        """
        from .sbom_generator import Vulnerability
        
        vulnerabilities = []
        
        for component in components:
            # Check if component has known vulnerabilities
            vuln_list = self._check_component_vulnerabilities(component)
            vulnerabilities.extend(vuln_list)
            
        return vulnerabilities
        
    def _check_component_vulnerabilities(self, component) -> List:
        """
        Check a single component for vulnerabilities
        
        Args:
            component: Component to check
            
        Returns:
            List of vulnerabilities found
        """
        from .sbom_generator import Vulnerability
        
        vulnerabilities = []
        
        # Create component identifier
        comp_id = f"{component.name}@{component.version}"
        
        # Check in vulnerability database
        if comp_id in self.vulnerability_db:
            for vuln_data in self.vulnerability_db[comp_id]:
                vulnerability = Vulnerability(
                    id=vuln_data['id'],
                    source=vuln_data.get('source', 'Local DB'),
                    severity=vuln_data.get('severity', 'medium'),
                    description=vuln_data.get('description', 'No description available'),
                    affected_components=[comp_id],
                    cve=vuln_data.get('cve'),
                    cvss_score=vuln_data.get('cvss_score'),
                    fix_available=vuln_data.get('fix_available', False),
                    fix_version=vuln_data.get('fix_version')
                )
                vulnerabilities.append(vulnerability)
                
        # Also check for partial version matches (e.g., all versions below X)
        vulnerabilities.extend(self._check_version_range_vulnerabilities(component))
        
        return vulnerabilities
        
    def _check_version_range_vulnerabilities(self, component) -> List:
        """
        Check for vulnerabilities that affect version ranges
        
        Args:
            component: Component to check
            
        Returns:
            List of vulnerabilities affecting version ranges
        """
        from .sbom_generator import Vulnerability
        
        vulnerabilities = []
        
        # Example logic for version range checking
        # In production, this would use proper version comparison libraries
        
        # Check for components with any version
        wildcard_key = f"{component.name}@*"
        if wildcard_key in self.vulnerability_db:
            for vuln_data in self.vulnerability_db[wildcard_key]:
                # Check if current version is affected
                if self._is_version_affected(component.version, vuln_data.get('affected_versions', '*')):
                    vulnerability = Vulnerability(
                        id=vuln_data['id'],
                        source=vuln_data.get('source', 'Local DB'),
                        severity=vuln_data.get('severity', 'medium'),
                        description=vuln_data.get('description', 'No description available'),
                        affected_components=[f"{component.name}@{component.version}"],
                        cve=vuln_data.get('cve'),
                        cvss_score=vuln_data.get('cvss_score'),
                        fix_available=vuln_data.get('fix_available', False),
                        fix_version=vuln_data.get('fix_version')
                    )
                    vulnerabilities.append(vulnerability)
                    
        return vulnerabilities
        
    def _is_version_affected(self, version: str, affected_range: str) -> bool:
        """
        Check if a version falls within an affected range
        
        Args:
            version: Version to check
            affected_range: Affected version range specification
            
        Returns:
            True if version is affected
        """
        # Simplified version checking
        # In production, use proper version comparison (e.g., packaging.version)
        
        if affected_range == '*':
            return True
            
        if affected_range.startswith('<'):
            # All versions below X
            try:
                threshold = affected_range[1:].strip()
                return self._compare_versions(version, threshold) < 0
            except:
                return False
                
        if affected_range.startswith('<='):
            # All versions below or equal to X
            try:
                threshold = affected_range[2:].strip()
                return self._compare_versions(version, threshold) <= 0
            except:
                return False
                
        return False
        
    def _compare_versions(self, v1: str, v2: str) -> int:
        """
        Simple version comparison
        
        Args:
            v1: First version
            v2: Second version
            
        Returns:
            -1 if v1 < v2, 0 if equal, 1 if v1 > v2
        """
        # Very simplified version comparison
        # In production, use packaging.version.parse
        
        try:
            # Remove common version prefixes
            v1 = v1.lstrip('v')
            v2 = v2.lstrip('v')
            
            # Split by dots and compare
            parts1 = [int(x) for x in v1.split('.')]
            parts2 = [int(x) for x in v2.split('.')]
            
            # Pad shorter version with zeros
            max_len = max(len(parts1), len(parts2))
            parts1.extend([0] * (max_len - len(parts1)))
            parts2.extend([0] * (max_len - len(parts2)))
            
            for p1, p2 in zip(parts1, parts2):
                if p1 < p2:
                    return -1
                elif p1 > p2:
                    return 1
                    
            return 0
        except:
            # If parsing fails, consider versions equal
            return 0
            
    def _load_vulnerability_database(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Load vulnerability database
        In production, this would load from a local CVE database
        
        Returns:
            Vulnerability database dictionary
        """
        # Example vulnerability database
        # In production, this would be loaded from a comprehensive local database
        return {
            # Specific version vulnerabilities
            'log4j@2.14.1': [
                {
                    'id': 'VULN-001',
                    'cve': 'CVE-2021-44228',
                    'severity': 'critical',
                    'description': 'Log4Shell - Remote code execution vulnerability',
                    'cvss_score': 10.0,
                    'fix_available': True,
                    'fix_version': '2.17.1',
                    'source': 'NVD'
                }
            ],
            'lodash@4.17.20': [
                {
                    'id': 'VULN-002',
                    'cve': 'CVE-2021-23337',
                    'severity': 'high',
                    'description': 'Command injection vulnerability',
                    'cvss_score': 7.2,
                    'fix_available': True,
                    'fix_version': '4.17.21',
                    'source': 'NPM Advisory'
                }
            ],
            'django@2.2.10': [
                {
                    'id': 'VULN-003',
                    'cve': 'CVE-2021-31542',
                    'severity': 'medium',
                    'description': 'Path traversal vulnerability',
                    'cvss_score': 5.3,
                    'fix_available': True,
                    'fix_version': '2.2.21',
                    'source': 'Django Security'
                }
            ],
            
            # Version range vulnerabilities
            'requests@*': [
                {
                    'id': 'VULN-004',
                    'severity': 'low',
                    'description': 'Potential security issue in versions below 2.20.0',
                    'affected_versions': '<2.20.0',
                    'fix_available': True,
                    'fix_version': '2.20.0',
                    'source': 'PyPI Advisory'
                }
            ],
            'express@*': [
                {
                    'id': 'VULN-005',
                    'severity': 'medium',
                    'description': 'XSS vulnerability in versions below 4.17.1',
                    'affected_versions': '<4.17.1',
                    'cve': 'CVE-2019-5413',
                    'cvss_score': 6.1,
                    'fix_available': True,
                    'fix_version': '4.17.1',
                    'source': 'NPM Advisory'
                }
            ]
        }
        
    def generate_vulnerability_report(self, vulnerabilities: List) -> Dict[str, Any]:
        """
        Generate a vulnerability summary report
        
        Args:
            vulnerabilities: List of Vulnerability objects
            
        Returns:
            Summary report dictionary
        """
        if not vulnerabilities:
            return {
                'summary': 'No vulnerabilities found',
                'total': 0,
                'by_severity': {},
                'fix_available': 0
            }
            
        # Count by severity
        severity_counts = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0
        }
        
        fix_available = 0
        cve_list = []
        
        for vuln in vulnerabilities:
            severity = vuln.severity.lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
                
            if vuln.fix_available:
                fix_available += 1
                
            if vuln.cve:
                cve_list.append(vuln.cve)
                
        return {
            'summary': f"Found {len(vulnerabilities)} vulnerabilities",
            'total': len(vulnerabilities),
            'by_severity': severity_counts,
            'fix_available': fix_available,
            'cve_list': cve_list,
            'recommendations': self._generate_recommendations(vulnerabilities)
        }
        
    def _generate_recommendations(self, vulnerabilities: List) -> List[str]:
        """
        Generate recommendations based on vulnerabilities
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            List of recommendations
        """
        recommendations = []
        
        # Check for critical vulnerabilities
        critical = [v for v in vulnerabilities if v.severity.lower() == 'critical']
        if critical:
            recommendations.append(f"URGENT: {len(critical)} critical vulnerabilities require immediate attention")
            
        # Check for available fixes
        fixable = [v for v in vulnerabilities if v.fix_available]
        if fixable:
            recommendations.append(f"Update {len(fixable)} components to fix known vulnerabilities")
            
        # Specific recommendations for common issues
        for vuln in vulnerabilities:
            if vuln.fix_available and vuln.fix_version:
                comp = vuln.affected_components[0] if vuln.affected_components else 'unknown'
                recommendations.append(f"Update {comp} to version {vuln.fix_version} or higher")
                
        return recommendations[:5]  # Return top 5 recommendations